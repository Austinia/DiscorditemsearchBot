"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WidgetManager = void 0;
const crypto_1 = require("crypto");
const url_1 = require("url");
const Collection_1 = __importDefault(require("../utils/Collection"));
const Widget_1 = require("../structures/Widget");
const Constants_1 = require("../utils/Constants");
const utils_1 = require("../utils");
const defaultCacheMaxSize = 100;
const defaultCacheMaxAge = 60000 * 60;
class WidgetManager {
    constructor(koreanbots, options) {
        var _a, _b, _c, _d;
        this.koreanbots = koreanbots;
        this.options = options;
        this.options = options !== null && options !== void 0 ? options : { cache: {} };
        const cacheOptionsProxy = new Proxy(this.options.cache, utils_1.CacheOptionsValidator());
        // const optionsProxy = new Proxy(this.options, WidgetManager.validator<WidgetManagerOptions>())
        cacheOptionsProxy.max = (_b = (_a = options === null || options === void 0 ? void 0 : options.cache) === null || _a === void 0 ? void 0 : _a.max) !== null && _b !== void 0 ? _b : defaultCacheMaxSize;
        cacheOptionsProxy.maxAge = (_d = (_c = options === null || options === void 0 ? void 0 : options.cache) === null || _c === void 0 ? void 0 : _c.maxAge) !== null && _d !== void 0 ? _d : defaultCacheMaxAge;
        this.cache = new Collection_1.default({
            max: this.options.cache.max,
            maxAge: this.options.cache.maxAge
        });
    }
    getVoteWidgetURL(id) {
        return `${this.koreanbots.api.client.globalUri}/widget/bots/votes/${id}.svg`;
    }
    getStatusWidgetURL(id) {
        return `${this.koreanbots.api.client.globalUri}/widget/bots/status/${id}.svg`;
    }
    getServerWidgetURL(id) {
        return `${this.koreanbots.api.client.globalUri}/widget/bots/servers/${id}.svg`;
    }
    async getVoteWidget(id, options = { format: "png" }) {
        const res = await this._fetch({
            target: "bots",
            type: "votes",
            id,
            ...options
        });
        const buffer = res !== null && res !== void 0 ? res : new Error(`"${id}" 봇에 대한 투표 수 위젯을 불러오는 것에 실패 했습니다.`);
        if (buffer instanceof Error)
            throw buffer;
        return buffer;
    }
    async getServerWidget(id, options = { format: "png" }) {
        const res = await this._fetch({
            target: "bots",
            type: "servers",
            id,
            ...options
        });
        const buffer = res !== null && res !== void 0 ? res : new Error(`"${id}" 봇에 대한 서버 수 위젯을 불러오는 것에 실패 했습니다.`);
        if (buffer instanceof Error)
            throw buffer;
        return buffer;
    }
    async getStatusWidget(id, options = { format: "png" }) {
        const res = await this._fetch({
            target: "bots",
            type: "status",
            id,
            ...options
        });
        const buffer = res !== null && res !== void 0 ? res : new Error(`"${id}" 봇에 대한 상태 위젯을 불러오는 것에 실패 했습니다.`);
        if (buffer instanceof Error)
            throw buffer;
        return buffer;
    }
    /**
     * 직접적인 사용이 권장되지 않습니다.
     */
    async _fetch(options, fetchOptions = { cache: true, force: false }) {
        var _a, _b, _c;
        const query = new url_1.URLSearchParams();
        const queryOptions = ["icon", "scale", "style"];
        const cacheKey = {
            id: options.id,
            style: options.style,
            scale: options.scale,
            icon: options.icon,
            target: options.target,
            type: options.type
        };
        const key = crypto_1.createHash("sha256").update(JSON.stringify(cacheKey)).digest("hex");
        const cache = this.cache.get(key);
        if (!(fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.force) && cache)
            return cache;
        for (const queryOption of queryOptions) {
            const value = ((_b = (_a = options[queryOption]) === null || _a === void 0 ? void 0 : _a.toString) === null || _b === void 0 ? void 0 : _b.call(_a)) || options[queryOption];
            if (options[queryOption] || typeof options[queryOption] === "boolean")
                query.append(queryOption, value);
        }
        const [res, sharp] = await Promise.allSettled([
            this.koreanbots.api({ global: true }).widget(options.target)(options.type)(`${options.id}.svg`).get({
                [Constants_1.KoreanbotsInternal]: {
                    query,
                    bodyResolver: (res) => res.buffer()
                }
            }),
            Promise.resolve().then(() => __importStar(require("sharp"))).catch(() => {
                throw new Error(`"${options.format}" 파일 형식으로 변환하기 위한 모듈 "sharp"를 찾을 수 없습니다.`);
            })
        ]);
        if (sharp.status === "rejected")
            throw new Error(sharp.reason);
        if (res.status === "fulfilled" && (options === null || options === void 0 ? void 0 : options.format) !== "svg") {
            const sh = sharp.value.default;
            const buffer = res.value.data;
            if (!buffer)
                throw new Error("위젯에서 Buffer 데이터를 읽을 수 없습니다.");
            let converted;
            switch (options === null || options === void 0 ? void 0 : options.format) {
                case "jpeg":
                case "jpg":
                    converted = sh(buffer).jpeg().toBuffer();
                    break;
                case "png":
                    converted = sh(buffer).png().toBuffer();
                    break;
                case "webp":
                    converted = sh(buffer).webp().toBuffer();
                    break;
                default:
                    converted = buffer;
                    break;
            }
            res.value.data = await converted;
        }
        const instance = res.status === "fulfilled" &&
            new Widget_1.Widget(this.koreanbots, (_c = res.value.data) !== null && _c !== void 0 ? _c : Buffer.alloc(0), options);
        if (!instance)
            throw new Error(res.reason);
        if (fetchOptions.cache)
            this.cache.set(key, instance);
        return instance;
    }
}
exports.WidgetManager = WidgetManager;
//# sourceMappingURL=WidgetManager.js.map