"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mybot = void 0;
const url_1 = require("url");
const Bot_1 = require("../structures/Bot");
const Constants_1 = require("../utils/Constants");
const Collection_1 = __importDefault(require("../utils/Collection"));
class Mybot {
    /**
     * 새로운 Mybot 인스턴스를 생성합니다.
     * @param koreanbots
     * @param clientID
     */
    constructor(koreanbots, clientID) {
        this.koreanbots = koreanbots;
        this.clientID = clientID;
        this.bot = null;
        this.votes = new Collection_1.default({
            maxAge: 10000
        });
        this.mybotInit();
    }
    async mybotInit() {
        const res = await this.koreanbots.api().bots(this.clientID).get();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.bot = new Bot_1.Bot(this.koreanbots, res.data);
    }
    /**
     * 해당 유저가 내 봇에 하트를 눌렀는지 체크합니다. (cache TTL: 10초)
     * @param id
     * @returns
     * @example
     * ```js
     * koreanbots.mybot.checkVote("12345678901234567")
     *     .then(voted => {
     *         if (voted) return message.channel.send(`${message.author} 님, 하트를 눌러주셔서 감사합니다!`)
     *
     *         return message.channel.send(`${message.author} 님, 하트를 아직 누르지 않으셨습니다.`)
     *     })
     * ```
     */
    async checkVote(id) {
        const cache = this.votes.get(id);
        if (cache)
            return cache;
        const query = new url_1.URLSearchParams();
        query.append("userID", id);
        const res = await this.koreanbots.api().bots(this.clientID).vote.get({
            [Constants_1.KoreanbotsInternal]: {
                query
            }
        });
        if (!res.data)
            throw new Error(res.message);
        return res.data;
    }
    /**
     * 봇의 서버 수를 업데이트합니다.
     * @example
     * ```js
     * koreanbots.mybot.update({ servers: client.guilds.cache.size })
     * ```
     */
    async update({ servers, shards }) {
        var _a, _b, _c;
        if (typeof servers !== "number" && servers !== undefined)
            throw new TypeError(`"count" 옵션은 숫자여야 합니다. (받은 타입: ${typeof servers})`);
        if (typeof shards !== "number" && shards !== null && shards !== undefined)
            throw new TypeError(`"shards" 옵션은 숫자, null 또는 undefined이여야 합니다. (받은 타입: ${typeof shards})`);
        if (!servers && !shards)
            throw new Error("\"servers\" 또는 \"shards\" 값이 제공되어야 합니다.");
        if (this.lastGuildCount === servers)
            return {
                code: 304,
                version: (_a = this.koreanbots.options.api.version) !== null && _a !== void 0 ? _a : 2,
                message: "서버 수가 같아서 업데이트 되지 않았습니다."
            };
        const body = JSON.stringify({
            servers: servers,
            shards
        });
        const response = await this.koreanbots.api().bots(this.clientID).stats.post({
            body
        });
        if (response.code !== 200 || !response.data)
            throw new Error(response.message ||
                `API에서 알 수 없는 응답이 돌아왔습니다. ${JSON.stringify(response.data)}`);
        this.lastGuildCount = servers;
        this.updatedTimestamp = Date.now();
        this.updatedAt = new Date(this.updatedTimestamp);
        if ((_b = this.koreanbots) === null || _b === void 0 ? void 0 : _b.api.client.listeners("serverCountUpdated"))
            (_c = this.koreanbots) === null || _c === void 0 ? void 0 : _c.api.client.emit("serverCountUpdated", { ...response.data, servers });
        return response.data;
    }
}
exports.Mybot = Mybot;
//# sourceMappingURL=Mybot.js.map