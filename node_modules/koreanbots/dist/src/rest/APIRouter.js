"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Constants_1 = require("../utils/Constants");
const RequestClient_1 = __importDefault(require("./RequestClient"));
/**
 * @license https://github.com/discordjs/discord.js/blob/master/LICENSE
 * @description
 * I, zero734kr, maintainer and lead developer of js-sdk of KOREANBOTS, declare
 * that this part of source code 'APIRouter.ts' is taken from
 * https://github.com/discordjs/discord.js/blob/master/src/rest/APIRouter.js,
 * and modified the original source code to be compatible with TypeScript
 * and KOREANBOTS API Routes. There were not many changes with original source code.
 * @see https://github.com/discordjs/discord.js/blob/master/src/rest/APIRouter.js
 */
// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };
const methods = ["get", "post", "delete", "patch", "put"];
const routesWithId = /bots|users|widget/;
const reflectors = [
    "toString",
    "valueOf",
    "inspect",
    "constructor",
    Symbol.toPrimitive,
    Symbol.for("nodejs.util.inspect.custom"),
];
let cachedClient;
function buildRoute(options) {
    const client = cachedClient || (cachedClient = new RequestClient_1.default(options));
    const api = (internalOptions = { global: false }) => {
        const route = [""];
        const handler = {
            get(target, name) {
                if (reflectors.includes(name))
                    return () => route.join("/");
                if (methods.includes(name)) {
                    const routeBucket = [];
                    for (let i = 0; i < route.length; i++) {
                        // Literal IDs should only be taken account if they are the Major ID (the Channel/Guild ID)
                        if (Constants_1.snowflakeRegex.test(route[i]) && !routesWithId.test(route[i - 1]))
                            routeBucket.push(":id");
                        // All other parts of the route should be considered as part of the bucket identifier
                        else
                            routeBucket.push(route[i]);
                    }
                    return (options) => {
                        let kInternal = {
                            ...internalOptions
                        };
                        if (options === null || options === void 0 ? void 0 : options[Constants_1.KoreanbotsInternal])
                            kInternal = { ...internalOptions, ...options[Constants_1.KoreanbotsInternal] };
                        return client.request(name.toUpperCase(), route.join("/"), {
                            ...options,
                            [Constants_1.KoreanbotsInternal]: kInternal
                        });
                    };
                }
                route.push(name);
                return new Proxy(noop, handler);
            },
            apply(target, _, args) {
                route.push(...args.filter(x => x != null));
                return new Proxy(noop, handler);
            }
        };
        return new Proxy(noop, handler);
    };
    api.client = client;
    return api;
}
exports.default = buildRoute;
//# sourceMappingURL=APIRouter.js.map