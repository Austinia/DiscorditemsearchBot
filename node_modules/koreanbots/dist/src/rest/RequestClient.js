"use strict";
/* eslint-disable @typescript-eslint/no-non-null-assertion */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importStar(require("node-fetch"));
const events_1 = require("events");
const url_1 = require("url");
const abort_controller_1 = __importDefault(require("abort-controller"));
const https = __importStar(require("https"));
const getRoute_1 = require("./getRoute");
const Utils = __importStar(require("../utils"));
const Constants_1 = require("../utils/Constants");
const Errors_1 = require("../utils/Errors");
const defaultRetryLimit = 5;
const defaultRequestTimeout = 30000;
const defaultApiVersion = 2;
const defaultUnstableOption = false;
class RequestClient extends events_1.EventEmitter {
    constructor(options) {
        var _a, _b, _c, _d;
        super();
        this.options = options;
        const optionsProxy = new Proxy(this.options, RequestClient.validator());
        optionsProxy.token = options.token;
        optionsProxy.version = (_a = options.version) !== null && _a !== void 0 ? _a : defaultApiVersion;
        optionsProxy.requestTimeout = (_b = options.requestTimeout) !== null && _b !== void 0 ? _b : defaultRequestTimeout;
        optionsProxy.retryLimit = (_c = options.retryLimit) !== null && _c !== void 0 ? _c : defaultRetryLimit;
        optionsProxy.unstable = (_d = options.unstable) !== null && _d !== void 0 ? _d : defaultUnstableOption;
        this.globalReset = null;
        this._destroyed = false;
        this._timeouts = new Set();
        this._agent = https.Agent ? new https.Agent({ keepAlive: !this._destroyed }) : void 0;
        this._retries = new Set();
        this.setupReadonly(options);
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    setupReadonly(options) {
        Object.defineProperties(this, {
            version: {
                writable: false,
                value: this.options.version
            },
            baseUri: {
                writable: false,
                value: getRoute_1.getVersionRoute(this.options.version, this.options.unstable)
            },
            globalUri: {
                writable: false,
                value: getRoute_1.getGlobalRoute(this.options.unstable)
            },
            token: {
                writable: false,
                value: this.options.token
            },
            headers: {
                writable: false,
                value: {
                    // idk why, but here was resulting 'undefined' when is 'this.token'
                    authorization: options.token,
                    "Content-Type": "application/json",
                    "User-Agent": `js-sdk/${Constants_1.version}`
                }
            }
        });
    }
    /**
     * @license https://github.com/discordjs/discord.js/blob/master/LICENSE
     * @see https://github.com/discordjs/discord.js/blob/d744e51c1bdb4c7a26c0faeea1f2f45baaf5fd3c/src/client/BaseClient.js#L80
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    setTimeout(func, time, ...args) {
        const tid = setTimeout(() => {
            func(...args);
            this._timeouts.delete(tid);
        }, time);
        this._timeouts.add(tid);
        return tid;
    }
    /**
     * @license https://github.com/discordjs/discord.js/blob/master/LICENSE
     * @see https://github.com/discordjs/discord.js/blob/d744e51c1bdb4c7a26c0faeea1f2f45baaf5fd3c/src/client/BaseClient.js#L93
     */
    clearTimeout(tid) {
        this._timeouts.delete(tid);
        return clearTimeout(tid);
    }
    destroy() {
        this._destroyed = true;
        for (const timeout of [...this._timeouts])
            this.clearTimeout(timeout);
        this._retries.clear();
        this.removeAllListeners();
    }
    async request(method, url, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        if (this.globalReset) {
            const delayFor = this.globalReset - Date.now();
            await Utils.waitFor(delayFor);
        }
        const controller = new abort_controller_1.default();
        const mergedOptions = {
            ...options,
            headers: this.headers,
            method,
            agent: this._agent,
            signal: controller.signal
        };
        const baseRoute = ((_a = mergedOptions[Constants_1.KoreanbotsInternal]) === null || _a === void 0 ? void 0 : _a.global)
            ? this.globalUri
            : this.baseUri;
        const query = typeof ((_b = mergedOptions[Constants_1.KoreanbotsInternal]) === null || _b === void 0 ? void 0 : _b.query) === "string"
            ? `?${(_c = mergedOptions[Constants_1.KoreanbotsInternal]) === null || _c === void 0 ? void 0 : _c.query}`
            : ((_d = mergedOptions[Constants_1.KoreanbotsInternal]) === null || _d === void 0 ? void 0 : _d.query) instanceof url_1.URLSearchParams
                ? `?${(_f = (_e = mergedOptions[Constants_1.KoreanbotsInternal]) === null || _e === void 0 ? void 0 : _e.query) === null || _f === void 0 ? void 0 : _f.toString()}`
                : "";
        const fetchUrl = `${baseRoute}${encodeURI(url)}${query}`;
        const timeout = this.setTimeout(() => {
            this.emit("timeout", {
                url,
                method,
                [Symbol("requestOptions")]: options
            });
            controller.abort();
        }, this.options.requestTimeout);
        let res;
        let r;
        try {
            const response = await node_fetch_1.default(fetchUrl, mergedOptions);
            res = await ((_j = (_h = (_g = mergedOptions[Constants_1.KoreanbotsInternal]) === null || _g === void 0 ? void 0 : _g.bodyResolver) === null || _h === void 0 ? void 0 : _h.call(_g, response)) !== null && _j !== void 0 ? _j : response.text()
                // code for debug
                .then(a => Utils.isJSON(a) ? JSON.parse(a) : (() => { throw a; })())
                .catch(console.error));
            r = response;
        }
        finally {
            this.clearTimeout(timeout);
        }
        if ((r.status >= 400 || r.status < 600) && r.status !== 429 && r.status !== 404) {
            const { retry } = (_k = [...this._retries].find(e => e.id === controller.signal)) !== null && _k !== void 0 ? _k : { retry: 0 };
            if (retry >= this.options.retryLimit)
                throw new Errors_1.KoreanbotsAPIError(
                // @ts-expect-error check
                `올바르지 않은 응답이 반환 되었습니다. ${((_l = res.data) === null || _l === void 0 ? void 0 : _l.message) || JSON.stringify(res.data)}`, r.status, method, url);
            this._retries.add({ id: controller.signal, retry: retry + 1 });
        }
        if (r.status === 429) {
            const delay = (parseInt((_m = r.headers.get("x-ratelimit-reset")) !== null && _m !== void 0 ? _m : "0") * 1000) - Date.now();
            const isGlobal = Boolean(r.headers.get("x-ratelimit-global"));
            this.clearTimeout(timeout);
            // request again if `this.globalReset` was already defined to handle global rate limit
            if (this.globalReset)
                return this.request(method, url, options);
            this.emit("rateLimit", {
                isGlobal,
                path: url,
                method,
                limit: parseInt((_o = r.headers.get("x-ratelimit-limit")) !== null && _o !== void 0 ? _o : "0"),
                retryAfter: parseInt((_p = r.headers.get("x-ratelimit-reset")) !== null && _p !== void 0 ? _p : "0") * 1000,
                [Symbol("requestOptions")]: options
            });
            // handle endpoint specific rate limit
            if (!isGlobal) {
                if (delay === 0)
                    return this.request(method, url, options);
                await Utils.waitFor(delay);
                return this.request(method, url, options);
            }
            this.globalReset = parseInt((_q = r.headers.get("x-ratelimit-reset")) !== null && _q !== void 0 ? _q : "0") * 1000;
            await Utils.waitFor(this.globalReset - Date.now());
            return this.request(method, url, options);
        }
        const response = {
            code: r.status,
            // @ts-expect-error generic
            data: (res === null || res === void 0 ? void 0 : res.data) ? res === null || res === void 0 ? void 0 : res.data : res,
            // @ts-expect-error generic
            message: res === null || res === void 0 ? void 0 : res.message,
            isCache: false,
            ratelimitRemaining: parseInt((_r = r.headers.get("x-ratelimit-remaining")) !== null && _r !== void 0 ? _r : "0"),
            url,
            updatedTimestamp: Date.now()
        };
        const req = new node_fetch_1.Request(fetchUrl, mergedOptions);
        this.emit("request", req, r);
        return response;
    }
}
RequestClient.validator = () => ({
    set: (obj, prop, value) => {
        switch (prop) {
            case "token":
                if (typeof value !== "string")
                    throw new TypeError(`"token" 옵션은 문자열이여야 합니다. (받은 타입: ${typeof value})`);
                // eslint-disable-next-line no-case-declarations
                const [algorithm, info] = value.split(".").map(e => {
                    const serialized = `${Buffer.from(e, "base64")}`;
                    const deserializable = Utils.isJSON(serialized);
                    return deserializable ? JSON.parse(serialized) : serialized;
                });
                if (algorithm.typ !== "JWT" || !Constants_1.snowflakeRegex.test(info.id))
                    throw new TypeError("주어진 \"token\" 옵션은 정상적인 KOREANBOTS JWT 토큰이 아닙니다.");
                break;
            case "noWarning":
                if (typeof value !== "boolean")
                    throw new TypeError(`"noWarning" 옵션의 타입은 boolean이여야 합니다. (받은 타입: ${typeof value})`);
                break;
            case "requestTimeout":
                if (typeof value !== "number")
                    throw new TypeError(`"requestTimeout" 옵션은 숫자여야 합니다. (받은 타입: ${typeof value})`);
                if (value <= 0)
                    throw new RangeError(`"requestTimeout" 옵션은 0보다 커야 합니다. (받은 값: ${value}, 최소보다 '${1 - value}' 작음)`);
                break;
            case "retryLimit":
                if (typeof value !== "number")
                    throw new TypeError(`"retryLimit" 옵션은 숫자여야 합니다.  (받은 타입: ${typeof value})`);
                if (value <= 0)
                    throw new RangeError(`"retryLimit" 옵션은 0보다 커야 합니다. (받은 값: ${value}, 최소보다 '${1 - value}' 작음)`);
                if (!Number.isSafeInteger(value))
                    throw new RangeError(`"retryLimit" 옵션은 32비트 정수만 허용됩니다. (받은 값: ${value})`);
                break;
            case "unstable":
                if (typeof value !== "boolean")
                    throw new TypeError(`"unstable" 옵션의 타입은 boolean이여야 합니다. (받은 타입: ${typeof value})`);
                break;
        }
        obj[prop] = value;
        return true;
    }
});
exports.default = RequestClient;
//# sourceMappingURL=RequestClient.js.map